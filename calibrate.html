<!doctype html>
<html>
<head>
	<title>GeoLight Interface</title>
	<meta charset="utf-8">

	<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
	<script src="http://code.jquery.com/ui/1.10.2/jquery-ui.min.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"></script>

  <script src="bootstrap/js/bootstrap.min.js" type="text/javascript"></script>
  <script src="lib/spin.min.js" type="text/javascript"></script>
	<script src="lib/d3.v3.min.js" type="text/javascript"></script>
	<script src="lib/tablesort.min.js" type="text/javascript"></script>
	<script src="lib/Blob.js" type="text/javascript"></script>
	<script src="lib/FileSaver.min.js" type="text/javascript"></script>

	<script src="js/base.js" type="text/javascript"></script>
	<script src="js/log.js"></script>

	<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link href="http://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.min.css" rel="stylesheet">
	<link href="http://netdna.bootstrapcdn.com/font-awesome/3.0.2/css/font-awesome.css" rel="stylesheet">

	<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.5/leaflet.css">
	<script src="http://cdn.leafletjs.com/leaflet-0.5/leaflet.js"></script>

	<script src="http://maps.google.com/maps/api/js?v=3.2&sensor=false"></script>
  <script src="https://gist.github.com/bencevans/4504864/raw/c9ef880071f959398b7cf0b687d4f37c352ea86d/leaflet-google.js"></script>

	<style>

		body {
			padding-bottom: 20px;
		}

		label {
			display: inline-block;
		}

		.well {
			background-color: #f9f9f9;
		}

		.alerts {
			margin-top: 10px;
		}

		.shortcuts.btn-toolbar {
			padding-top: 10px;
		}
		.shortcuts.btn-toolbar .btn {
			min-width: 32px;
		}
		.input-append {
			display: inline;
		}

		#map {
			height: 400px;
		}

		.inconsistent-state {
			color: red !important;
		}

		#chart {
		  font: 10px sans-serif;
		  margin-bottom: 20px;
		  /*overflow-x: scroll;*/
			border: 1px solid #ddd;
			position: relative;
		}

		#activity-indicator {
			position: absolute;
			left: 400px; /* 960/2 - 160/2 */
			top: 100px;
			background: #333;
			color: white;
			width: 160px;
			height: 100px;
			text-align: center;
			-webkit-border-radius: 10px;
			-moz-border-radius: 10px;
			border-radius: 10px;
		}
		#activity-spinner {
			margin-top: 40px;
		}
		#activity-indicator p {
			clear: both;
			bottom: 10px;
			font-size: 16px;
			margin-top: 70px;
		}

		.control-interface {
			min-height: 420px;
		}
		.control-interface form {
			margin-bottom: 10px;
		}
		.control-interface .control-group {
			margin-bottom: 10px;
		}
		.control-interface .control-label {
			width: 100px;
		}
		.control-interface .controls {
			margin-left: 110px;
		}
		.control-interface a {
			font-size: 0.9em;
		}
		.control-interface hr {
			margin: 10px 0;
		}
		.control-interface .xor {
			text-align:center;
			text-transform: uppercase;
			font-size: 0.8em;
			font-weight: bold;
		}
		.control-interface .submit {
			width: 100%;
			text-align: center;
		}

		#table-events .visible td {
			background-color: #FFEF99;
		}

		/* table sort */

		th.sort-header {
		  cursor:pointer;
		  }
		th.sort-header::-moz-selection,
		th.sort-header::selection {
		  background:transparent;
		  }
		table th.sort-header:after {
		  content:'';
		  float:right;
		  margin-top:7px;
		  border-width:0 4px 4px;
		  border-style:solid;
		  border-color:#404040 transparent;
		  visibility:hidden;
		  }
		table th.sort-header:hover:after {
		  visibility:visible;
		  }
		table th.sort-up:after,
		table th.sort-down:after,
		table th.sort-down:hover:after {
		  visibility:visible;
		  opacity:0.4;
		  }
		table th.sort-up:after {
		  border-bottom:none;
		  border-width:4px 4px 0;
		  }

		.ui-datepicker { 
			font-size: 12px !important;
			line-height: 14px !important;
		}

		/* the chart */

		#calibration-pattern path {
    	fill: none;
    	stroke: white;
    	stroke-width: 1px;
    	stroke-linejoin: 'miter';
    	stroke-linecap: 'square';
    }
    #calibration-pattern .background {
    	fill: green;
    	stroke: none;
    	stroke-width: 0;
    }

		.axis path,
		.axis line {
			shape-rendering: crispEdges;
		  fill: none;
		  stroke: #000;
		}

		.x.axis path {
		  display: none;
		}

		.line {
		  fill: none;
		  stroke: #37b3f6;
		  stroke-width: 1px;
		}

		.context .line {
			stroke: #37b3f6;
		}

		.line.daybefore {
			stroke: #dcdcdc;
		}
		.line.dayafter {
			stroke: #dcdcdc;
		}

		.datapoint {
			stroke: none;
			stroke-width: 0;
			fill: #000;
		}

		.brush .extent {
			shape-rendering: crispEdges;
		  stroke: rgb(201, 117, 117);
		  fill-opacity: .125; /*ms?*/
		}
		.rangerect {
			shape-rendering: crispEdges;
			stroke: #fff;
			fill-opacity: .30;
		}

		.threshold {
			shape-rendering: crispEdges;
			fill: none;
			stroke: #d42111;
		}
		.threshold-indicator {
			cursor: ns-resize;
		}

		.calibration-event {
			shape-rendering: crispEdges;
			fill: none;
			stroke: #000;
			filter: alpha(opacity=100);
			opacity: 1.0;
		}

		.calibration-indicator {
			fill: none;
			stroke: #000;
			stroke-width: 1px;	
			filter: alpha(opacity=50);
			opacity: 0.5;
		}

		.calibration-indicator.inactive {
			filter: alpha(opacity=20);
			opacity: 0.2;
		}

		.sunset {
			fill: #888;
		}

		.sunrise {
			fill: white;
		}

		.removed {
			filter: alpha(opacity=20);
			opacity: 0.2;
		}

		th.include, td.include {
			text-align: center;
		}

		.problem {
			shape-rendering: crispEdges;
			stroke: none;
			stroke-width: 0;
			fill: red;

			filter: alpha(opacity=20);
			opacity: 0.2;
		}

		.info-hud text {
			shape-rendering: crispEdges;
			font-size: 11px;
			stroke-width: 0;
			stroke: none;
			fill: #555;
		}
		.info-hud > rect {
			fill: #fff;
			stroke-width: 0;
			stroke: none;
			filter: alpha(opacity=50);
			opacity: 0.5;
		}

	</style>

	<script>
		_.templateSettings = {
		  interpolate : /\{\{(.+?)\}\}/g
		};

		_.reversecopy = function(a) {
			var temp = [];
	    var len = a.length;
	    for (var i = (len - 1); i >= 0; i--) {
	        temp.push(a[i]);
	    }
	    return temp;
		}

		_.filterUntil = function(flag, list, iterator) {
			var results = [];
			for ( var i = 0; i < list.length; i++ ) {
				var res = iterator(list[i]);
				if (res==false) continue;
				if (res==flag) break;
				results.push(list[i]);
			}
			return results;
		}

		String.prototype.capitalize = function() {
	    return this.charAt(0).toUpperCase() + this.slice(1);
		}
	</script>

	<script>

	var app = new Base();

	$(document).ready(function() {
		"use strict";

		// useful time constants

		var OneMinute = 1000*60;
		var OneHour = 1000*60*60;
		var OneDay = 1000*60*60*24;
		var OneHalfDay = OneDay/2;
		var OneQuarterDay = OneDay/4;

		// default values
		
		app.set('threshold',5.5); // threshold
		app.set('data',[]); // lightvalues, the dataset
		app.set('events',[]); // threshold events
		app.set('extent',[]); // focused extent
		app.set('problems',[]); // noisy twilight areas
		app.set('calibrationPeriod',[undefined,undefined]); // calibration
		app.set('releaseLocation',[undefined,undefined]); // lat & lon
		app.set('angleComputed', false);
		app.set('birdLocations',[]);
		app.set('sunangle',undefined);
		app.set('tagname',undefined);
		app.set('notes',undefined);

		// settings

		app.set('showSurroundingDays', false);

		// the chart
		// state: 0=initial, 1=loading, 2=loaded
		
		app.chart = Base.extend((function() {
			
			var	thIndicator,
					thLine;

			var margin = {top: 20, right: 20, bottom: 100, left: 50},
			    margin2 = {top: 330, right: 20, bottom: 20, left: 50},
			    width = 940 - margin.left - margin.right,
			    height = 400 - margin.top - margin.bottom,
			    height2 = 400 - margin2.top - margin2.bottom;

		  var x = d3.time.scale().range([0, width]),
			    x2 = d3.time.scale().range([0, width]),
			    y = d3.scale.linear().range([height, 0]),
			    y2 = d3.scale.linear().range([height2, 0]);

		  var xAxis = d3.svg.axis().scale(x).orient("bottom"),
			    xAxis2 = d3.svg.axis().scale(x2).orient("bottom"),
			    yAxis = d3.svg.axis().scale(y).orient("left");

			var brush = d3.svg.brush()
			    .x(x2)
			    .on("brush", brushdrag);

		  // functions

		  var parseDate = d3.time.format("%Y-%m-%d %H:%M:%S").parse;
		  var parseUTCDate = d3.time.format.iso.parse;

		  // draws the primary view

		  var line = d3.svg.line()
		    .x(function(d) { return x(d.datetime); })
		    .y(function(d) { return y(d.light); });

		  // draws the brush overview

		  var line2 = d3.svg.line()
		    .x(function(d) { return x2(d.datetime); })
		    .y(function(d) { return y2(d.light); });

		  // build the chart

			var svg = d3.select("#chart").append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom);

			svg.append("defs").append("clipPath")
			    .attr("id", "clip")
				  .append("rect")
				    .attr("width", width)
				    .attr("height", height);

			 // primary viewing area

			var focus = svg.append("g")
					.attr('class','focus')
			    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			// with background

			focus.append('g').attr('class','background');

			// data grouping, comparator in background, points in foreground

			var datagroup = focus.append('g').attr('class','datagroup');
			var comparator = datagroup.append('g').attr('class','comparator');
			var datapointer = focus.append('g').attr('class','datapointer');

			// and info overlay

			focus.append('g').attr('class','info-hud')
					.attr('transform', "translate(" + (width-240) + "," + 0 + ")")
					.append('rect')
						.attr('x',0)
						.attr('y',0)
						.attr('width',240)
						.attr('height',48);

			// overview area

			var context = svg.append("g")
					.attr('class','context')
    			.attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    	// with background

    	context.append('g').attr('class', 'background');

    	function brushdrag(evt) {
    		// should not need to duplicate the plotting functionality
			  x.domain(brush.empty() ? x2.domain() : brush.extent());
			  app.set('extent',x.domain());
			  focus.select(".x.axis").call(xAxis);
			  redrawPaths();
			}

			function redrawThreshold(t) {
				thLine
					.attr("y1", y(t.toFixed(1)))
					.attr("y2", y(t.toFixed(1)));
				thIndicator
					.attr('y', y(t.toFixed(1))-8);
		  }

		  function scrollTo(start,stop) {
		  	svg.select('.brush').call(brush.extent([start,stop]));
			  brushdrag();
		  }

		  function shiftData(data, delta) {
		  	return _.map(data, function(d) {
		  		var event = _.extend({},d);
		  		event.datetime = new Date(d.datetime.valueOf()+delta);
		  		return event;
		  	});
		  }

		  function zonedDateString(datestring) {
		  	// firefox requires the Z, mongo remove it
		  	return datestring.charAt(datestring.length-1) == 'Z' ?
					     datestring : 
					     datestring+"Z"
		  }

		  function redrawPaths() {
		  	
		  	// DUPLICATED
		  	var start = x.domain()[0].getTime();
		  	var stop = x.domain()[1].getTime();

				var data = _.filterUntil(undefined,app.get('data'),function(d) {
					if ( d.datetime.getTime() > stop+OneDay ) {
						return undefined;
					}
					return ( d.datetime.getTime() >= start-OneDay && 
		  				 		 d.datetime.getTime() <= stop+OneDay );
				});

		  	d3.select('.line.dayof').remove();
		  	datagroup.append("path")
					      .datum(data)
					      .attr("clip-path", "url(#clip)")
					      .attr("class", "line dayof")
					      .attr("d", line);

				// DUPLICATED
				if ( app.get('showSurroundingDays') ) {

					var daybefore = shiftData(data,-OneDay);
					d3.select('.line.daybefore').remove();
			   	comparator.append("path")
				      .datum(daybefore)
				      .attr("clip-path", "url(#clip)")
				      .attr("class", "line daybefore")
				      .attr("d", line);

				  var dayafter = shiftData(data,OneDay);
				  d3.select('.line.dayafter').remove();
			   	comparator.append("path")
				      .datum(dayafter)
				      .attr("clip-path", "url(#clip)")
				      .attr("class", "line dayafter")
				      .attr("d", line);
				}
		  }

		  app.addObserver('threshold', redrawThreshold);

			return {

				load: function(filepath) {

					var me = this;
					
					//http://test.cybercommons.org/mongo/db_find/geologger/lightlogs/
					/* {"spec": 
						{
							"tagname":"PABU222150755",
							"user_id":"guest"
							}
						}
					*/

					//var tempurl = 'http://test.cybercommons.org/mongo/db_find/geologger/lightlogs/{"spec": { "tagname":"PABU222150755", "user_id":"guest" }}';

					var url = 'http://test.cybercommons.org/mongo/db_find/geologger/lightlogs/';
					url += ( '{"spec": { "tagname":"'+filepath+'", "user_id":"guest" }}' )

					me.set('readyState',1);	
					d3.json(url, function(error,json) {
					  app.set('releaseLocation',json[0].release_location);
					  app.set('tagname',json[0].tagname);
					  app.set('notes',json[0].notes);
					  app.set('data',json[0].data);

					  var data = json[0].data;
					  //log(json);

					  data.forEach(function(d) {
					    d.datetime = parseUTCDate(zonedDateString(d.datetime));
					    d.light = +d.light;
					  });

					  x.domain(d3.extent(data, function(d) { return d.datetime; }));
					  y.domain(d3.extent(data, function(d) { return d.light; }));
					  
					  x2.domain(x.domain());
  					y2.domain(y.domain());

					  // data, day before, day after
					  // drawing deferred to redrawPaths for optimization

					  context.append("path")
				      	.datum(data)
				      	.attr("class", "line")
				      	.attr("d", line2);

				    // axes

					  focus.append("g")
				      .attr("class", "x axis")
				      .attr("transform", "translate(0," + height + ")")
				      .call(xAxis);
					  
				   	context.append("g")
				      .attr("class", "x axis")
				      .attr("transform", "translate(0," + height2 + ")")
				      .call(xAxis2);

					  focus.append("g")
				      .attr("class", "y axis")
				      .call(yAxis)
					    .append("text")
					      .attr("transform", "rotate(-90)")
					      .attr("y", 6)
					      .attr("dy", "-3.5em")
					      .attr("dx","-14em")
					      .style("text-anchor", "end")
					      .text("Light");

				    // brush 

				   	context.append("g")
				      .attr("class", "x brush")
				      .call(brush)
					    .selectAll("rect")
					      .attr("y", -6)
					      .attr("height", height2 + 7);

					  // threshold

					  var thresholdDrag = d3.behavior.drag()
							.on("drag", function(d) {
								var t = y.invert(d3.event.y);
								if ( t >= y.domain()[0] && t <= y.domain()[1] ) {
									app.set('threshold',t);
								}
							});

					 	thLine = focus.append("line")
					 		.style("stroke-dasharray", ("2, 2"))
				  		.attr("class","threshold")
				  		.attr("x1", 6)
				  		.attr("y1", y(app.get('threshold')))
				  		.attr("x2", 870)
				  		.attr("y2", y(app.get('threshold')))
				  		.call(thresholdDrag);

				  	thIndicator = focus.append('image')
				  		.attr('class','threshold-indicator')
				  		.attr('xlink:href','img/threshold-triangle.png')
				  		.attr('height','16px')
				  		.attr('width','16px')
				  		.attr('x', -40)
				  		.attr('y', y(app.get('threshold'))-8)
				  		.call(thresholdDrag);

				  	// support chart drag

				  	/*
				  	var dragfocus = d3.behavior.drag()
							.origin(function() {
								log({x:d3.event.x, y:d3.event.y});
								return {x:d3.event.x, y:d3.event.y};
							})
							.on("drag", function(d) {
								log(d3.event.dx);
							});

						svg.call(dragfocus);
						*/

				  	// make the scale publicly available ~ do not set from outside

				  	me.set('x',x);
				  	me.set('y',y);

				  	me.set('x2',x2);
				  	me.set('y2',y2);

				  	// update the threshold to force redraw and recalibration
				  	// set an initial brush extent and calibration range

				  	app.set('threshold',app.get('threshold'));
 	
				  	var start = data[0].datetime,
				  			focusstop = new Date(data[0].datetime.getTime()+OneDay*7),
				  			calibstop = new Date(data[0].datetime.getTime()+OneDay*14);
						
						app.set('calibrationPeriod',[start,calibstop]);
				  	scrollTo(start,focusstop);
				  	me.set('readyState',2);
					});
				}, // end load

				// composed utilities: make our methods pretty

				scrollTo: function(start,stop) {
					scrollTo(start,stop);
				},

				domainMin: function() {
					return x2.domain()[0].getTime();
				},

				domainMax: function() {
					return x2.domain()[1].getTime();
				},

				yMin: function() {
					return y.domain()[0];
				},

				yMax: function() {
					return y.domain()[1];
				},

				extentMin: function() {
					return x.domain()[0].getTime();
				},

				extentMax: function() {
					return x.domain()[1].getTime();
				},

				extentRange: function() {
					return x.domain()[1].getTime() - x.domain()[0].getTime();
				},

				extentCenter: function() {
					return this.extentMin() + this.extentRange() / 2;
				},

				constrainToDomainMax: function(time) {
					return ( time > this.domainMax() ?
						this.domainMax() :
						time );
				},

				constrainToDomainMin: function(time) {
					return ( time < this.domainMin() ?
						this.domainMin() :
						time );
				},

				constrainToLightRange: function(light) {
					if (light < this.yMin() ) light = this.yMin();
	  			if (light > this.yMax() ) light = this.yMax();
	  			return light;
				},

				// zoomIn, zoomOut:
				// adjust the brush extent, ensuring we do not extend
			  // beyong the edge or zoom in less than one quarter day

				zoomIn: function() {
			  	var start = this.constrainToDomainMin(this.extentMin()+OneQuarterDay);
			  	var stop = this.constrainToDomainMax(this.extentMax()-OneQuarterDay);
			  	if ( stop - start >= OneHalfDay ) { 
			  		this.scrollTo(start,stop);
			  	}
			  },

			  zoomOut: function() {
			  	var start = this.constrainToDomainMin(this.extentMin()-OneQuarterDay);
			  	var stop = this.constrainToDomainMax(this.extentMax()+OneQuarterDay);
			  	this.scrollTo(start,stop);
			  },

			  // gotoPreviousSection, gotoNextSection:
			  // adjust the brush extent, preserving width against the edge

			  gotoPreviousSection: function() {
		  		var start = this.constrainToDomainMin(
		  			this.extentMin()-this.extentRange()
		  		);
			  	this.scrollTo(start,start+this.extentRange());
			  },

			  gotoNextSection: function() {
		  		var stop = this.constrainToDomainMax(
		  			this.extentMax()+this.extentRange()
		  		);
			  	this.scrollTo(stop-this.extentRange(),stop);
			  },

			  gotoBeginning: function() {
			  	this.scrollTo(this.domainMin(),this.domainMin()+this.extentRange());
			  },

			  gotoEnd: function() {
			  	this.scrollTo(this.domainMax()-this.extentRange(),this.domainMax());
			  },

			  toggleSurroundingDays: function() {
			  	//$('.line.daybefore, .line.dayafter').toggle();
			  	app.set('showSurroundingDays', !app.get('showSurroundingDays'));
			  	if ( !app.get('showSurroundingDays') ) {
			  		d3.select('.line.daybefore').remove();
						d3.select('.line.dayafter').remove();
			  	} else {
			  		redrawPaths();
			  	}
			  },

			  surroundDaysVisible: function() {
			  	return !comparator.select('.line.daybefore').empty();
			  },

			  redrawPoints: function() {
			  	var start = this.extentMin();
			  	var stop = this.extentMax();
			  	var data = _.filter(app.get('data'), function(d) {
			  		return d.datetime.getTime() >= start && 
			  					 d.datetime.getTime() <= stop;
			  	});

			  	datapointer.selectAll('.datapoint').remove();
			  	datapointer.selectAll('.datapoint')
			  		.data(data).enter()
						.append('circle')
						.attr("clip-path", "url(#clip)")
						.attr('class','datapoint')
						.attr('cx',function(d) { return x(d.datetime); })
						.attr('cy',function(d) { return y(d.light); })
						.attr('r',1);
			  },

			  togglePoints: function() {
			  	if ( this.pointsVisible() ) {
			  		datapointer.selectAll('.datapoint').remove();
					} else {
						this.redrawPoints();
					}
			  },

			  pointsVisible: function() {
			  	return !datapointer.select('.datapoint').empty();
			  }
			};
		})());

		// date range, built to scale
		// date x position should be a function of the date value
		// and y should be fixed

		app.calibrationModule = Base.extend((function() {

			var calibPattern = d3.select('#chart svg').append('pattern')
      		.attr('id', 'calibration-pattern')
      		.attr('patternUnits', 'userSpaceOnUse')
      		.attr('x', 0)
      		.attr('y', 0)
      		.attr('width', 4)
      		.attr('height', 4);
      calibPattern.append('rect')
    			.attr('class','background')
    			.attr('x', 0)
      		.attr('y', 0)
      		.attr('width', 4)
      		.attr('height', 4);
      calibPattern
      		.append('path')
      		.attr('d', 'M 0 4 4 0');

      d3.select('#chart svg defs').append("clipPath")
      		.attr('id', 'calibClip')
      		.append('rect')
      			.attr('width',870) // hardcoded from chart
      			.attr('height',12) // approx. hardcoding
      			.attr('y',-12);

			function redrawRangeIndicators(range) {
				if (!range.length == 2 || !range[0] || !range[1])
					return;

				var focus = d3.select("#chart svg .focus");
				var context = d3.select("#chart svg .context .background");
				var x2 = app.chart.get('x2');
				var x = app.chart.get('x');

				// draw in two places? at least on the brush

				context.select('.rangerect').remove();
				context.append('rect')
					.attr('class','rangerect')
					.attr('x', x2(range[0]))
					.attr('y', -6)
					.attr('width',x2(range[1])-x2(range[0]))
					.attr('height',5)
					.attr('fill','url(#calibration-pattern)');

				focus.select('.rangerect').remove();
				focus.append('rect')
					.attr('clip-path','url(#calibClip)')
					.attr('class','rangerect')
					.attr('x', x(range[0]))
					.attr('y', -12)
					.attr('width',x(range[1])-x(range[0]))
					.attr('height',10)
					.attr('fill','url(#calibration-pattern)');
			}

			app.addObserver('calibrationPeriod', function(range) {
				redrawRangeIndicators(range);
			});
			app.addObserver('extent', function(extent) {
				redrawRangeIndicators(app.get('calibrationPeriod'));
			});

			return {};

		}()));

		// events, affect the chart and events table
		// including problem areas

		app.eventModule = Base.extend((function() {

			var eventSort = new Tablesort($('#table-events').get(0));
			eventSort.current = $('#table-events .event-header').get(0);
			eventSort.sortTable($('#table-events .event-header').get(0));

			var isSunrise = function(d) { return d.get('type') == "sunrise"; }
			var isSunset = function(d) { return d.get('type') == "sunset"; }

			var eventsLayer = d3.select("#chart svg .focus")
				.append('g').attr('class','twiglight-events');

		  function drawEvents() {

		  	var focus = d3.select("#chart svg .focus");
		  	var events = app.get('events');
		  	var x = app.chart.get('x');
		  	var y = app.chart.get('y');
	
			  eventsLayer.selectAll('.calibration-indicator').remove();
				eventsLayer.selectAll('.calibration-indicator')
		  		.data(events)
		  		.enter()
		  		.append('circle')
		  			.attr("clip-path", "url(#clip)")
		  			.attr("class","calibration-indicator")
		  			.attr('data-index', function(d) { return events.indexOf(d); })
		  			.attr('id', function(d) { return 'data-index-'+events.indexOf(d); })
		  			.classed("sunset", isSunset)
		  			.classed("sunrise", isSunrise)
		  			.classed('inactive', function(d) { return !d.get('active'); })
		  			.attr("cx", function(d) { return x(d.get('datetime')); }) 
		  			.attr("cy", y(app.get('threshold'))) 
		  			.attr("r",4);

		  	eventsLayer.selectAll('.calibration-indicator')
		  		.on("click", function(d,i) {
		  			d.set('active',!d.get('active'));
		  			this.parentNode.insertBefore(this, this.parentNode.firstChild);
		  			d3.select(this).classed('inactive', !d.get('active'));
			  	})
			  	.on("mouseover", function(d,i) {
			  		d3.select(this).transition()
			  			.attr('r',5);
			  		d3.select('.info-hud')
			  			.append('text')
			  				.attr('class','datetime')
			  				.attr('text-anchor','end')
			  				.attr('x',230)
			  				.attr('y',28)
			  				.text(d.get('datetime'));
			  		d3.select('.info-hud')
			  			.append('text')
			  				.attr('class','event-type')
			  				.attr('text-anchor','end')
			  				.attr('x',230)
			  				.attr('y',42)
			  				.text(d.get('type').capitalize());
			  	})
			  	.on("mouseout", function(d,i) {
			  		d3.select(this).transition()
			  			.attr('r',4);
			  		d3.select('.info-hud .datetime')
			  			.remove();
			  		d3.select('.info-hud .event-type')
			  			.remove();
			  	});
		  }

		  function recomputeCalibrationEvents() {
			 
		  	var t = +app.get('threshold').toFixed(1);
		  	var data = app.get('data');
		  	var events = [];

		  	for ( var i = 1; i < data.length-1; i++ ) {
		  		var p1 = data[i], p2 = data[i+1], pm1 = data[i-1];
		  		if (lightValueCrossesThreshold(p1,p2,t)) {
		  			var twilightEvent = twilightEventAt(p1,p2,pm1,t);
		  			if ( twilightEvent) events.push(twilightEvent);
		  		}
		  	};

		  	return events;
	  	}

	  	function twilightEventAt(p1,p2,pm1,t) {
	  		var attrs = { threshold: t, active: true };

	  		if ( lightValueIsAtThreshold(p1,t) ) {
	  			attrs.type = twilightTypeAtThreshold(pm1, p2, t);
	  			attrs.datetime = p1.datetime;
	  		} else if ( lightValueCrossesThresholdFalling(p1,p2,t) ) {
	  			attrs.datetime = new Date(x3at(p1,p2,t));
	  			attrs.type = 'sunset';
	  		} else if ( lightValueCrossesThresholdRising(p1,p2,t) ) {
	  			attrs.datetime = new Date(x3at(p1,p2,t));
	  			attrs.type = 'sunrise';
	  		} else {
	  			return null;
	  		}

	  		return Base.extend(null,attrs);
	  	}

	  	function lightValueIsAtThreshold(p,t) {
	  		return (p.light == t);
	  	}

	  	function lightValueCrossesThresholdFalling(p1,p2,t) {
	  		return (p1.light > t && p2.light < t);
	  	}

	  	function lightValueCrossesThresholdRising(p1,p2,t) {
	  		return (p1.light < t && p2.light > t);
	  	}

	  	function lightValueCrossesThreshold(d1,d2,t) {
	  		return ( lightValueIsAtThreshold(d1,t) ||
	  						 lightValueCrossesThresholdFalling(d1,d2,t) ||
	  						 lightValueCrossesThresholdRising(d1,d2,t) );
	  	}

	  	function twilightTypeAtThreshold(da,db,t) {
	  		if ( da.light >= t && db.light <= t ) return 'sunset';
		  	else return 'sunrise';
	  	}

	  	function x3at(point1, point2, y3) {
	  		var x1 = point1.datetime.getTime(),
	  				y1 = point1.light,
	  				x2 = point2.datetime.getTime(), 
	  				y2 = point2.light;

	  		var m = (y2-y1)/(x2-x1);
	  		var x3 = ((y3-y1)+(x1*m))/m;
	  		return x3;
	  	}

	  	function recomputeProblemEvents(events) {
	  		
	  		// spec: a problem knows which events it encompasses,
	  		// and events know which problem they lie within

	  		var kspan = OneHour*3;
	  		var problems = [];

	  		for (var i = 0; i < events.length-1; i++) {
	  			var start = events[i].get('datetime');
	  		
	  			var r = 1; // range
	  			while ( i+r < events.length ) { // misses final problem
	  				var stop = events[i+r].get('datetime');
	  				if ( stop.getTime() - start.getTime() > kspan ) {
	  					if ( r > 1 ) {
	  						var actStop = events[i+r-1].get('datetime');
	  						var problem = Base.extend(null,{
	  							events: events.slice(i,i+r),
	  							start: start,
	  							stop: actStop,
	  							active: true
	  						});
	  						events.slice(i,i+r).forEach(function(d) {
	  							d.set('problem',problem);
	  						});
	  						problems.push(problem);
	  						i = i+r-1; // skip
	  					}
	  					break;
	  				}
	  				r++;
	  			}
	  		}

	  		return problems;
	  	}

	  	function activeProblems() {
	  		return _.filter(app.get('problems'), function(d) {
		  		return d.get('active');
		  	});
	  	}

	  	function problemIsActive(problem) {
	  		return ( _.reduce( problem.get('events'), function(memo,e) {
					return memo + ( e.get('active') ? 1 : 0 );
				}, 0) > 1 );
	  	}

	  	function drawProblems() {
				var background = d3.select("#chart svg .focus .background");
		  	var problems = activeProblems();
		  	var x = app.chart.get('x');

		  	background.selectAll('.problem').remove();
		  	background.selectAll('.problem')
	  			.data(problems).enter()
	  			.append('rect')
		  			.attr("clip-path", "url(#clip)")
	  				.attr('class', 'problem')
	  				.attr('x', function(d) { return x(d.get('start'))-7; })
	  				.attr('y',0)
	  				.attr('width',function(d) {
	  					return x(d.get('stop'))-x(d.get('start'))+14;
	  				})
	  				.attr('height',280);

	  		var description = "Problem areas: " + String(problems.length);
		  	d3.select('.info-hud .problem-description').remove();
		  	d3.select('.info-hud')
	  			.append('text')
	  				.attr('class','problem-description')
	  				.attr('text-anchor','end')
	  				.attr('x',230)
	  				.attr('y',14)
	  				.text(description);
		  }

		  function clearExcludedEventsTable() {
		  	$('#table-events tbody .event').remove();
		  	$('#table-events tbody .nodata').css('display','table-row');
		  }

		  function updateExcludedEventsTable(event) {
		  	var id = event.get('datetime').getTime();
				var tbody = $('#table-events tbody');
				var row = tbody.children('[data-datetime='+id+']');
				if (row.length > 0 && event.get('active')) {
					row.remove();
				} else if (row.length == 0 && !event.get('active')) {
					var template = $('script#event-row').html();
					var newrow = tbody.append( _.template(template,{
						datetime: event.get('datetime').toUTCString(),
						type: event.get('type'),
						id: id
					}));
					newrow.find('a').click(handleEventTableClick);
				}
				// update the visibility of the nodata row
				if ( tbody.children('.event').length > 0 ) {
					tbody.children('.nodata').css('display','none');
				} else {
	  			tbody.children('.nodata').css('display','table-row');
	  		}
	  		// and sort
	  		eventSort.refresh();
		  }

		  function updateVisibilityInExcludedEventsTable(range) {
		  	$('#table-events tbody tr').each(function(i) {
		  		var dt = $(this).attr('data-datetime');
		  		if ( dt >= range[0] && dt <= range[1] ) $(this).addClass('visible');
		  		else $(this).removeClass('visible');
		  	});
		  }

		  // selecting an event in the excluded table shows it on the chart

		  function handleEventTableClick() {
		  	var center = $(this).attr('data-datetime');
		  	var visible = app.chart.extentRange();
		  	var start = app.chart.constrainToDomainMin(center-visible/2);
				var stop = app.chart.constrainToDomainMax(start+visible);
				app.chart.scrollTo(start,stop);
				return false;
		  };
	  	
		  app.addObserver('threshold', function(t) {
	  		var events = recomputeCalibrationEvents();
	  		if (events) app.set('events',events);
	  		var problems = recomputeProblemEvents(events);
	  		if (problems) app.set('problems',problems);
	  		clearExcludedEventsTable();
	  		drawEvents();
			});

			app.addObserver('extent', function(e) {
				drawEvents();
				drawProblems();
				updateVisibilityInExcludedEventsTable(e);
			});

			app.addObserver('problems',function(p) {
				drawProblems();
			});
		  
			app.addObserver('events', function(evts) {
				evts.addObserver('active', function(a) {
					var problem = this.get('problem');
					if (problem) {
						problem.set('active', problemIsActive(problem) );
						drawProblems();
					}
					updateExcludedEventsTable(this);
					updateVisibilityInExcludedEventsTable(app.get('extent'));
				});
			});

			return {

				// previousProblem, nextProblem:
			  // find the problem before/after the max current extent
	  		// and center on it

	  		previousProblem: function() {
	  			return _.find(_.reversecopy(activeProblems()), function(x) {
	  				return x.get('stop').getTime() < app.chart.extentCenter()-OneHour; 
	  			});
	  		},

	  		nextProblem: function() {
	  			return _.find(activeProblems(), function(x) {
	  				return x.get('start').getTime() > app.chart.extentCenter()+OneHour;
	  			});
	  		},

			  gotoPreviousProblem: function() {
	  			var visiblility = app.chart.extentRange();
  				var previous = this.previousProblem();
	  			if (previous) {
	  				var start = app.chart.constrainToDomainMin(
	  					previous.get('start').getTime()-visiblility/2
	  				);
	  				app.chart.scrollTo(start,start+visiblility);
		  		}
			  },

			  gotoNextProblem: function() {
			  	var visiblility = app.chart.extentRange();
	  			var next = this.nextProblem();
	  			if (next) {
		  			var stop = app.chart.constrainToDomainMax(
		  				next.get('start').getTime()+visiblility/2
		  			);
		  			app.chart.scrollTo(stop-visiblility,stop);
		  		}
			  }
			};

		})());

		app.mapModule = Base.extend((function() {

			// don't like the code that depends on the presence of
			// outside html elements: bad depedency: $('a[href=#map-tab]')

			// TODO: clear layer

			var mapRendered = false;
			var geoLayer = undefined;

			/*var wholeEarth = new L.LatLngBounds( 
				new L.LatLng(-90,-180), 
				new L.LatLng(90,180));*/
			var map = L.map('map', {
				keyboard: false,
				center: [25, 0],
				/*maxBounds: wholeEarth,*/
				minZoom: 1,
				zoom: 1
			});
			var googleLayer = new L.Google('ROADMAP');
      map.addLayer(googleLayer);
      
			/*
			L.tileLayer('http://{s}.tile.cloudmade.com/41d74d0a4bce4413bde0ea29c36e63cb/997/256/{z}/{x}/{y}.png', {
		    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://cloudmade.com">CloudMade</a>',
		    maxZoom: 16
			}).addTo(map);
			*/

			var geojsonMarkerOptions = {
		    radius: 4,
		    fillColor: "#ff7800",
		    color: "#000",
		    weight: 1,
		    opacity: 1,
		    fillOpacity: 0.8
			};

			function removeNullCoordinates(coordinates) {
				return _.filter(coordinates, function(coord) {
					return (coord[0] && coord[1]);
				});
			}

			function setConsistent(consistent) {
				if (!consistent) {
					$('a[href=#map-tab]').addClass('inconsistent-state');
					$('[for=map]').tooltip({
						title: 'Map is inconsistent: re-submit to update',
						placement: 'right'
					});
				} else {
					$('a[href=#map-tab]').removeClass('inconsistent-state');
					$('[for=map]').tooltip('destroy');
				}
			}

			function invalidateMap() {
				if (!mapRendered) return;
				setConsistent(false);
			}

			// map does not draw initially when hidden, force redraw on show

			$('a[href=#map-tab]').on('shown', function (e) {			 
			 	map.invalidateSize();
			});

			// when calibration parameters change, show that map is inconsistent
		
			app.addObserver(['threshold','calibrationPeriod','releaseLocation',
				'sunangle'], function() {
				invalidateMap();
			});

			app.addObserver('events', function(evts) {
				evts.addObserver('active', function(a) {
					invalidateMap();
				});
			});

			return {
				drawGeoJSON: function(geo) {
					mapRendered = true; // damn you, state, damn you!
					setConsistent(true);

					if (geoLayer) map.removeLayer(geoLayer);

					//geo.geometry.coordinates = removeNullCoordinates(geo.geometry.coordinates);
					geoLayer = L.geoJson(geo, {
						pointToLayer: function (feature, latlng) {
		       		return L.circleMarker(latlng, geojsonMarkerOptions);
		       	},
		       	onEachFeature: function(feature, layer) {
		       		layer.on('click',function(e) {
		       			//log(feature.properties);
		       			var start = d3.time.format.iso.parse(feature.properties.tFirst);
		       			var stop = d3.time.format.iso.parse(feature.properties.tSecond);
		       			if (start.getTime() == stop.getTime()) {
		       				stop = new Date(stop.getTime() + 24*OneHour);
		       			}
		       			app.chart.scrollTo(start,stop);
		       		})
		       	}
		      });
		      geoLayer.addTo(map);
				},

				redrawMap: function() {
					map.invalidateSize();
				},

				invalidateMap: function() {
					invalidateMap();
				}

			};
		})());

		var DateFormat = "yy-mm-dd";

		// interface preparation

		$('#sun-angle-indicator').hide();
		$('#submit-for-processing i').hide();

		// set up page observers and interactions: data-bindings

		$('[data-toggle=popover]').popover({html:true});

		// latitude and longitude

		app.addObserver('releaseLocation', function(loc) {
			$('input[name=latitude]').val(loc[0]);
			$('input[name=longitude]').val(loc[1]);
		});
		$('input[name=latitude]').change(function() {
			var loc = app.get('releaseLocation');
			loc[0] = $(this).val();
			app.set('releaseLocation',loc);
		});
		$('input[name=longitude]').change(function() {
			var loc = app.get('releaseLocation');
			loc[1] = $(this).val();
			app.set('releaseLocation',loc);
		});

		// threshold

		app.addObserver('threshold', function(t) {
			$('#threshold-val').val(t.toFixed(1));
		});
	  $('#increase-threshold').click(function() {
	  	app.set('threshold',app.get('threshold')+0.1);
	  	return false;
	  });
	  $('#decrease-threshold').click(function() {
	  	app.set('threshold',app.get('threshold')-0.1);
	  	return false;
	  });
	  $('#threshold-val').change(function() {
	  	var t = app.chart.constrainToLightRange( Number($(this).val()) );
	  	app.set('threshold', t);
	  	return false;
	  });
	  $('#threshold-val').keydown(function(e) {
	  	if (e.keyCode == 38) {
	  		app.set('threshold',app.get('threshold')+0.1);
	  	} else if (e.keyCode == 40) {
	  		app.set('threshold',app.get('threshold')-0.1);
	  	}
	  });

	  // calibration period

	  app.addObserver('calibrationPeriod', function(r) {
	  	$('input[name=cal-start-date]').val(
	  		$.datepicker.formatDate(DateFormat,r[0])
	  		);
	  	$('input[name=cal-stop-date]').val(
	  		$.datepicker.formatDate(DateFormat,r[1])
	  		);
	  });
	  $('input[name=cal-start-date]').change(function() {
	  	var daterange = app.get('calibrationPeriod');
	  	daterange[0] = $(this).datepicker('getDate');
	  	app.set('calibrationPeriod',daterange);
	  });
	  $('input[name=cal-stop-date]').change(function() {
	  	var daterange = app.get('calibrationPeriod');
	  	daterange[1] = $(this).datepicker('getDate');
	  	app.set('calibrationPeriod',daterange);
	  });

	  // sun angle

	  app.addObserver('sunangle', function(a) {
	  	$('input[name=sun-angle]').val(a);
	  });
	  $('input[name=sun-angle]').change(function() {
	  	app.set('sunangle',$(this).val());
	  });

	  // control group and their appwide keyboard shortcuts

	  $('[data-function=zoomIn]').click(function() {
	  	app.chart.zoomIn(); return false;
	  });
		$('[data-function=zoomOut]').click(function() {
			app.chart.zoomOut(); return false;
		});
		$('[data-function=previousSection]').click(function() {
			app.chart.gotoPreviousSection(); return false;
		});
		$('[data-function=nextSection]').click(function() {
			app.chart.gotoNextSection(); return false;
		});
		$('[data-function=gotoBeginning]').click(function() {
			app.chart.gotoBeginning(); return false;
		});
		$('[data-function=gotoEnd]').click(function() {
			app.chart.gotoEnd(); return false;
		});
		$('[data-function=gotoPreviousProblem]').click(function() {
			app.eventModule.gotoPreviousProblem(); return false;
		});
		$('[data-function=gotoNextProblem]').click(function() {
			app.eventModule.gotoNextProblem(); return false;
		});
	  $('[data-function=toggleSurroundingDays]').click(function() { 
	  	app.chart.toggleSurroundingDays(); return false;
	  });
	  $('[data-function=togglePoints]').click(function() { 
	  	app.chart.togglePoints(); return false;
	  });

	  $(document).keydown(function(e) {
	  	if ($('*:focus').prop('tagName') == 'INPUT' )
	  		return;
	  	if (e.which == 37 || e.which == 39) { 
	  		e.preventDefault(); // left or right key
	  		if (e.shiftKey) {
	  			if (app.get('problems').length == 0) return;
	  			if (e.which == 37) app.eventModule.gotoPreviousProblem();
	  			if (e.which == 39) app.eventModule.gotoNextProblem();
	  		} else {
		  		if (e.which == 37) app.chart.gotoPreviousSection();
		  		if (e.which == 39) app.chart.gotoNextSection();
			  }
		  } else if ( e.which == 88 || e.which == 90 ) {
		  	e.preventDefault(); // z and x keys
		  	if (e.which == 88) app.chart.zoomIn();
		  	if (e.which == 90) app.chart.zoomOut();
		  } else if ( e.which == 79 || e.which == 80 ) {
		  	e.preventDefault(); // o and p keys
		  	if (e.which == 79) app.chart.toggleSurroundingDays();
		  	if (e.which == 80) app.chart.togglePoints();
		  }
	  });

	  // main progress indicator

	  var sp, spinner;
	  app.chart.addObserver('readyState', function(state) {
	  	if ( state == 1) {
				sp = document.getElementById('activity-indicator');
				spinner = new Spinner({color:'#fff'}).spin(document.getElementById('activity-spinner'));
	  	} else if ( state == 2 ) {
			  spinner.stop();
			  sp.parentNode.removeChild(sp);
	  	}
	  });
		
		app.chart.addObserver('readyState', function(state) {
			if ( state == 2 ) {
				$('input[name=cal-start-date], input[name=cal-stop-date]').datepicker({
					showOtherMonths: true,
      		selectOtherMonths: true,
      		defaultDate: new Date(app.chart.domainMin()),
      		minDate: new Date(app.chart.domainMin()),
      		maxDate: new Date(app.chart.domainMax()),
      		dateFormat: DateFormat
				});
			}
		});

		// point updating ~ cannot draw all points simultaneously
		// and datagroup updating ~ optimize

		app.addObserver('extent', function() {
	  	if ( app.chart.pointsVisible() ) {
	  		app.chart.redrawPoints();
	  	}
		});
	  
		// processing
		// ToDo: Remove dummy tag name
		// ToDo: Check for remaining problems

		function pollStatus(args) {
	    $.getJSON(args.host + args.task_id + '?callback=?')
        .fail(function(jqXHR, status) {
        	args.onFailure(jqXHR, status);
        })
        .done(function(data) {
	        if (data.status == "PENDING") {
	          args.onPending(args.task_id);
	        } else if (data.status == "FAILURE") {
	          args.onFailure(data);
	        } else if (data.status == "SUCCESS") {
	          args.onSuccess(data);
	        }
	      });
		}

		function getStatus(taskID) {
			log("fetching status",taskID);
			var promise = new $.Deferred();
			var timer;
			var args = {
				host: 'http://test.cybercommons.org/queue/task/',
				task_id: taskID,
				onFailure: function(data) {
					clearInterval(timer);
					promise.reject(undefined,data);
				},
				onSuccess: function(data) {
					clearInterval(timer);
					promise.resolve(data);
				},
				onPending: function() {
					; // nothing
				}
			}
			timer = setInterval(function () {
				pollStatus(args);
			}, 2000);
			return promise;
		}

		$('#compute-sun-angle').click(function() {
			if (!validateForSunAngle()) return false;

			var $indicator = $('#sun-angle-indicator');

			var url = "http://test.cybercommons.org/queue/run/geologger.getElevation@geologger";
			var data = formattedEventData(app.get('events'),app.get('calibrationPeriod'));
			var postdata = {
				release_location: app.get('releaseLocation'),
				threshold: app.get('threshold'),
				tagname: app.get('tagname'),
				twilights: data
			}
			
			log(postdata);
			
			startProgressIndicator($indicator);
			$.post(url,{data: JSON.stringify(postdata)}, null, "json")
				.fail(function(jqXHR, status) {
					log("post failed", status);
					stopProgressIndicator($indicator);
				})
				.done(function(data) {
					log("post completed",data, typeof data);
					if (!data.task_id) {
						log("no task id returned");
						stopProgressIndicator($indicator);
						return;
					}
					getStatus(data.task_id)
						.always(function() {
							stopProgressIndicator($indicator);
						})
						.fail(function(jqXHR, status) {
							log("failed to retrieve task status",status);
						})
						.done(function(data) {
							var angle = data.tombstone[0].result.sunelevation;
							log("task status resolved", angle, data);
							app.set('angleComputed',true);
							app.set('sunangle',angle);
						});
				});

			return false;
		});

		$('#submit-for-processing').click(function() {
			if (!validateForProcessing()) return false;

			var $indicator = $('#submit-for-processing i');
			var $text = $('#submit-for-processing .text');
			var $btn = $(this);
		
			var url = 'http://test.cybercommons.org/queue/run/geologger.coord@geologger';
		
			var data = formattedEventData(app.get('events'));
			var postdata = {
				threshold: +app.get('threshold'),
				tagname: app.get('tagname'),
				twilights: data,
				calibperiod: app.get('calibrationPeriod'),
				sunelevation: app.get('sunangle'),
				computed: app.get('angleComputed'),
				release_location: app.get('releaseLocation')
			};

			startProgressIndicator($indicator);
			$.post(url,{data: JSON.stringify(postdata)}, null, "json")
				.fail(function(jqXHR, status) {
					log("post failed", status);
					$text.text('Error! Try again in a few seconds');
					$btn.addClass('btn-danger');
					setTimeout(function() {
						$text.text("Submit for processing");
						$btn.removeClass('btn-danger');
						$btn.addClass('btn-primary');
					},8000);
				})
				.done(function(data) {
					log("post completed",data);
					$text.text('Data are being processed');
					
					getStatus(data.task_id)
						.always(function() {
							stopProgressIndicator($indicator);
							$btn.removeClass('btn-primary');
						})
						.fail(function(jqXHR, status) {
							log("failed to retrieve task status",status);
							$text.text('Error! Try again in a few seconds');
							$btn.addClass('btn-danger');
							setTimeout(function() {
								$text.text("Submit for processing");
								$btn.removeClass('btn-danger');
								$btn.addClass('btn-primary');
							},8000);
						})
						.done(function(data) {
							log("status completed, grabbing geojson");
							$text.text('Success! Loading map data');
							$btn.addClass('btn-info');

							$('#app-tabs a[href="#map-tab"]').tab('show');
							getGeoJSON();

							setTimeout(function() {
								$text.text("Submit for processing");
								$btn.removeClass('btn-info');
								$btn.addClass('btn-primary');
							},8000);
						});
				});
		
			return false;
		});

		function getGeoJSON() {

			var url = 'http://test.cybercommons.org/mongo/db_find/geologger/coord/';
			var props = {
				spec: {
					"properties.tagname": app.get('tagname'),
					"properties.user_id": "guest"
				},
				sort: [["properties.timestamp",-1]],
				limit: 1
			}

			url += JSON.stringify(props);

			$.getJSON(url)
				.fail(function(jqXHR, status) {
	        log("geojson get failed", status);
        })
        .done(function(data) {
        	log("post completed",data);
        	app.mapModule.drawGeoJSON(data[0].features);
        	updateCoordinates(data[0].features);
        });
		}

		function updateCoordinates(features) {
			app.set('birdLocations', _.map(features, function(d) {
				return d.geometry.coordinates;
			}));
		}

		function formattedEventData(data,range) {
			// convert datetime fields to tFirst and tSecond for R processing
			var fdata = _.map(data, function(d) { return d.toObject(); });
			if (range) fdata = _.filter(fdata, function(d) {
				return d.datetime >= range[0] && d.datetime <= range[1];
			});

			for (var i = 0; i < fdata.length-1; i++) {
				fdata[i].tFirst = fdata[i].datetime;
				fdata[i].tSecond = fdata[i+1].datetime;
				delete fdata[i].datetime;
				delete fdata[i].threshold;
				delete fdata[i].problem;
			}
			return fdata.slice(0,-1);
		}

		function startProgressIndicator($indicator) {
			$indicator.show();
		}

		function stopProgressIndicator($indicator) {
			$indicator.hide();
		}

		// data validation prior to posting

		function validateForSunAngle() {
			hideAllLabelTooltips();
			if (!lightThresholdIsValid(app.get('threshold'))) {
				showTooltipForLabel('threshold'); 
				return false;
			}
			if (!releaseLocationIsValid(app.get('releaseLocation'))) {
				showTooltipForLabel('latitude'); 
				return false;
			}
			if (!calibrationPeriodIsValid(app.get('calibrationPeriod'))) {
				showTooltipForLabel('cal-start-date'); 
				return false;
			}
			return true;
		}

		function validateForProcessing() {
			hideAllLabelTooltips();
			if (!lightThresholdIsValid(app.get('threshold'))) {
				showTooltipForLabel('threshold');
				return false;
			}
			if (!releaseLocationIsValid(app.get('releaseLocation'))) {
				showTooltipForLabel('latitude');
				return false;
			}
			if (!sunAngleIsValid(app.get('sunangle'))) {
				showTooltipForLabel('sun-angle');
				return false;
			}
			return true;
		}

		function hideAllLabelTooltips() {
			$('label[data-error=tooltip]').tooltip('destroy');
		}

		function showTooltipForLabel(name) {
			$('[for='+name+']').tooltip('show');
		}

		function lightThresholdIsValid(threshold) {
			if (!threshold) return false;
			return true;
		}

		function releaseLocationIsValid(location) {
			if (!location.length==2 || !location[0] || !location[1]) {
				return false;
			} else {
				return true;
			}
		}

		function calibrationPeriodIsValid(period) {
			if (!period.length==2 || !period[0] || !period[1] || 
					 period[0] >= period[1]) {
				return false;
			} else {
				return true;
			}
		}

		function sunAngleIsValid(angle) {
			if (!angle) return false;
			return true;
		}

		// http://stackoverflow.com/questions/280713/elements-order-in-a-for-in-loop
		// All browsers respect definition order with the exception of Chrome and 
		// Opera which do for every non-numerical property name.
		// Really need to test this output

		$('#export-csv').click(function(d) {
			exportAsCSV(tildeData());
			return false;
		});

		$('#export-json').click(function(d) {
			exportAsJSON(tildeData());
			return false;
		});

		$('#export-map').click(function(d) {
			exportMapAsCSV(_.clone(app.get('birdLocations')));
			return false;
		});

		function tildeData() {
			var data = _.map(app.get('data'), function(d) {
				return _.clone(d); // js references are problematic
			});

			// add required csv fields to existing light data

			_.each(data, function(d) {
				d.twilight = 0;
				d.interp = "FALSE";
				d.excluded = "FALSE";
			});

			// format twilight events

			var events = _.map(app.get('events'), function(e) {
				var t = e.toObject();
				var type = 0;
				if (t.type == "sunrise") type = 1;
				else if (t.type == "sunset") type = 2;
				var r = {};

					r.datetime = t.datetime;
					r.light = t.threshold;
					r.twilight = type;
					r.interp = "TRUE";
					r.excluded = (t.active?"FALSE":"TRUE");

				return r;
			});
			
			// add twilight events to light data and sort

			data = data.concat(events);
			data = _.sortBy(data, function(d) {
				return d.datetime;
			});

			// filter out light data that has been duplicated by twilight events
			// and set interp to false for the twilight event

			var dataOut = [];
			for (var i = 0; i < data.length-1; i++) {
				if (data[i].datetime.getTime() != data[i+1].datetime.getTime()) {
					dataOut.push(data[i]);
				} else {
					// ensure the duplication is a light-twilight dup 
					// and not a light-light
					if (data[i+1].twilight != 0) {
						data[i+1].interp = "FALSE";
					}
				}
			}

			return dataOut;
		}

		function exportAsCSV(dataOut) {
			
			// one more pass converting date values to iso

			_.each(dataOut, function(d) {
				d.datetime = d.datetime.toISOString();
			});

			// add csv fields
			dataOut.unshift({
				datetime: 'datetime', 
				light: 'light',
				twilight: 'twilight',
				interp: 'interp',
				excluded: 'excluded'
			});

			var csv = arrayOfObjectsToCSV(dataOut);
			saveAs(
	      new Blob([csv], {
	      	type: "text/csv;charset=" + document.characterSet
	      }), app.get('tagname')+".csv"
	    );
			
			//var uriContent = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);
			//var myWindow = window.open(uriContent, "Tilde CSV");
		}

		function exportAsJSON(dataOut) {

			// R serializes table data rather strangely, but economically
			
			var tilde = {
				datetime: [],
				light: [],
				twilight: [],
				interp: [],
				excluded: []
			}

			_.each(dataOut, function(d) {
				tilde.datetime.push(d.datetime);
				tilde.light.push(d.light);
				tilde.twilight.push(d.twilight);
				tilde.interp.push(d.interp);
				tilde.excluded.push(d.excluded);
			});

			// and we have metadata

			var allOut = {
				tilde: tilde,
				latlngs: app.get('birdLocations'),
				metadata: {
					tagname: app.get('tagname'),
					tagid: app.get('tagname'),
					solar_elevation: app.get('sunangle'),
					calibration: [
						{
							location: app.get('releaseLocation'),
							start_time: app.get('calibrationPeriod')[0],
							stop_time: app.get('calibrationPeriod')[1]
						}
					],
					release_location: app.get('releaseLocation'),
					release_time: "NA",
					recapture_location: "NA",
					recapture_time: "NA",
					notes: app.get('notes'),
					species: "NA"
				}
			}

			var json = JSON.stringify(allOut, null, "  ");
			saveAs(
	      new Blob([json], {
	      	type: "application/json;charset=" + document.characterSet
	      }), app.get('tagname')+".json"
	    );
		}

		function exportMapAsCSV(dataOut) {
			dataOut.unshift(['lat', 'lng']);
			var csv = arrayOfArraysToCSV(dataOut);
			saveAs(
	      new Blob([csv], {
	      	type: "text/csv;charset=" + document.characterSet
	      }), app.get('tagname')+"_latlng.csv"
	    );
		}

		function arrayOfObjectsToCSV(array) {
			var keys = _.keys(array[0]);
			var csv = '';
			_.each(array, function(d) {
				csv += _.map(keys,function(k) {
					return d[k];
				}).join(',');
				csv += '\r\n';
			});
			return csv;
		}

		function arrayOfArraysToCSV(array) {
			var csv = '';
			_.each(array, function(d) {
				csv += d.join(',');
				csv += '\r\n';
			});
			return csv;
		}

		// clear error on input label once editing begins
		
		$('input').focus(function() {
			$(this).parents('.error-group')
				.find('label[data-error=tooltip]')
				.tooltip('destroy');
		}); 

	  function loadChart(filename) {
	  	//app.chart.load("/datasets/"+filename);
	  	$('.tagname').text(filename);
	  	app.chart.load(filename); // error checking
	  }

	  // load the dataset for visualization // ?callback=? jsonp

	  loadChart(window.location.hash.slice(1));	 

  });
	</script>

</head>
<body>

<div class="navbar navbar-static-top">
  <div class="navbar-inner">
  	<div class="container">
	    <span class="brand" href="">Geologgers</span>
	    <ul class="nav">
	      <li><a href="index.html">Datasets</a></li>
	    </ul>
	    <ul class="nav pull-right">
	    	<li><a href=""></a></li>
	    </ul>
	  </div>
  </div>
</div>

<div class="container">

	<div class="row">
		<div class="span12">

			<div class="btn-toolbar pull-right shortcuts">
			  <div class="btn-group">
			    <button class="btn btn-mini" title="Beginning" data-function="gotoBeginning">
			    	<i class="icon-double-angle-left"></i>
			    </button>
			    <button class="btn btn-mini" title="Previous section: left-arrow" data-function="previousSection">
			    	<i class="icon-angle-left"></i>
			    </button>
			    <button class="btn btn-mini" title="Next section: right-arrow" data-function="nextSection">
			    	<i class="icon-angle-right"></i>
			    </button>
			    <button class="btn btn-mini" title="End" data-function="gotoEnd">
			    	<i class="icon-double-angle-right"></i>
			   	</button>
			  </div>
			  <div class="btn-group">
			    <button class="btn btn-mini" title="Previous error: shift-left-arrow" data-function="gotoPreviousProblem">
			    	<i class="icon-circle-arrow-left"></i>
			    </button>
			    <button class="btn btn-mini" title="Next error: Shift-Right-Arrow" data-function="gotoNextProblem">
			    	<i class="icon-circle-arrow-right"></i>
			    </button>
			  </div>
			  <div class="btn-group">
			    <button class="btn btn-mini" title="Zoom out: z" data-function="zoomOut">
			    	<i class="icon-zoom-out"></i>
			    </button>
			    <button class="btn btn-mini" title="Zoom in: z" data-function="zoomIn">
			    	<i class="icon-zoom-in"></i>
			    </button>
			  </div>
			  
			  <div class="btn-group">
			  	<button class="btn btn-mini" title="Settings" data-function="settings" data-toggle="dropdown">
			  		<i class="icon-cog"></i>
			  	</button>
				  <button href="" class="btn btn-mini" data-toggle="popover" 
				  	data-placement="bottom" title="Keyboard Shortcuts" 
				  	data-content="
							Left arrow: previous section<br>
							Right arrow: next section<br><br>
							Shift + left arrow: previous error<br>
							Shift + right arrow: next error<br><br>
							Z: zoom out<br>
							X: zoom in<br><br>
							O: show +/- 24 hours<br>
							P: show points
							">
						<i class="icon-info-sign"></i>
					</button>
					<ul class="dropdown-menu pull-right" role="menu" aria-labelledby="dropdownMenu">
					  <li><a tabindex="-1" href="#overlay" data-function="toggleSurroundingDays">Overlay +/- 24 hours</a></li>
					  <li><a tabindex="-1" href="#points" data-function="togglePoints">Show individuals data points</a></li>
					</ul>
			  </div>
				
			</div>

			<h3><span class="tagname">PABU222150714_curtailed</span> <span class="muted">GeoLight</span></h3>

		</div>
	</div>

	<!--
	<div class="row ">
		<div class="span12">
			<div class="alert alert-info">
				<button type="button" class="close" data-dismiss="alert">&times;</button>
				<p>
					<strong>Instructions</strong>:
					Calibrate and clean up your dataset to submit it for processing.<br>
					1) Specify a light threshold for twilight events.
					2) Review the problem areas and remove erroneous twilight events.<br>
					3) Set calibration coordinates and a calibration period for the sun angle, or provide a sun angle.
					4) Submit.
				</p>
				<p>
					<strong>Shortcuts</strong>
				</p>
			</div>
		</div>
	</div>
	-->

	<div class="row">
		<div class="span12">

			<div id="chart">
				<div id="activity-indicator">
					<div id="activity-spinner"></div>
					<p>Loading Dataset</p>
				</div>
				<!-- placeholder -->
			</div>

		</div>
	</div>

	<div class="row">
		<div class="span8">
			
			<ul class="nav nav-tabs" id="app-tabs">
			  <li class="active"><a href="#events-tab" data-toggle="tab">Excluded Events</a></li>
			  <li><a href="#map-tab" data-toggle="tab" for="map">Locations Map</a></li>
			</ul>

			<div class="tab-content">
			  <div class="tab-pane active" id="events-tab">
			  	
			  	<script type="text/template" id="event-row">
						<tr data-datetime={{id}} class="event">
							<td data-sort={{id}}><a href="#" data-datetime="{{id}}"><small>{{datetime}}</small></a></td>
							<td><small>{{type}}</small></td>
						</tr>
					</script>

					<table class="table table-condensed table-bordered table-striped" id="table-events">
						<thead>
							<tr>
								<th class="event-header">Excluded Events: Date &amp; Time</th>
								<th class="no-sort">Event Type</th>
							</tr>
						</thead>
						<tbody>
							<tr class="nodata no-sort" data-datetime="0">
								<td colspan="2" class="include">No data</td>
							</tr>
						</tbody>
					</table>
				</div>

			  <div class="tab-pane" id="map-tab">
			  	<!-- map placeholder -->
			  	<div id="map"></div>
			  </div>
			</div>

		</div> <!-- table span -->
		<div class="span4">

			<div class="well control-interface">

				<div class="form-horizontal error-group">
					<div class="control-group">
						<label class="control-label" for="threshold" data-toggle="tooltip" data-trigger="manual" data-placement='left' data-error='tooltip' title="Specify a twilight light level threshold">Light Threshold</label>
    				<div class="controls">
							<div class="input-append">
							  <input type="text" id="threshold-val" class="input-mini">
							  <button class="btn" id="decrease-threshold">-</a>
							  <button class="btn" id="increase-threshold">+</a>
							</div>
						</div>
					</div>
				</div>

				<hr>

				<h5>Calibration Coordinates</h5>
				<div class="form-horizontal error-group">
					<div class="control-group">
						<label class="control-label" for="latitude" data-toggle="tooltip" data-trigger="manual" data-placement='left' data-error='tooltip' title="Specify latitude and longitude">Latitude</label>
						<div class="controls">
			   			<input type="text" class="span2" name="latitude" placeholder="metadata">
			    	</div>
			    </div>
			    <div class="control-group">
						<label class="control-label" for="longitude">Longitude</label>
			   		<div class="controls">
			   			<input type="text" class="span2" name="longitude" placeholder="metadata">
			   		</div>
			   	</div>
				</div>

				<hr>

				<h5>Calibration Period <span class="muted">for sun angle</span></h5>
				
				<div class="form-horizontal error-group">
				  <div class="control-group">
						<label class="control-label" for="cal-start-date" data-toggle="tooltip" data-trigger="manual" data-placement='left' data-error='tooltip' title="Specify start and stop dates with an earlier start date">Start Date</label>   
				    <div class="controls">
				    	<input type="text" class="span2" name="cal-start-date" placeholder="select">
				    </div>
			    </div>
			    <div class="control-group">
						<label class="control-label" for="cal-stop-date">Stop Date</label>   
				    <div class="controls">
				    	<input type="text" class="span2" name="cal-stop-date" placeholder="select">
				    </div>
				 	</div>
				 	<div class="control-group">
				 		<label class="control-label">
				 			<i class="icon-refresh icon-spin" id="sun-angle-indicator" style="position:relative;left:0px;top:-4px;"></i>
				 		</label>
				 		<div class="controls">
				 			<a href="" id="compute-sun-angle">Compute sun angle</a><br>
				 			<span class="xor">OR SUPPLY</span>
				 		</div>
				 	</div>
				 	<div class="control-group error-group">
						<label class="control-label" for="sun-angle" data-toggle="tooltip" data-trigger="manual" data-placement='left' data-error='tooltip' title="Specify a sun angle or compute from calibration period">Sun Angle</label>   
				    <div class="controls">
				    	<div class="input-append">
				    		<input type="text" class="span2" name="sun-angle" style="width:100px" placeholder="angle">
				    		<span class="add-on" style="min-width:14px;">&deg;</span>
				    	</div>
				    </div>
				 	</div>
				</div>

				<hr>

				<button class="submit btn btn-primary" id="submit-for-processing" style="position:relative;">
					<i class="icon-refresh icon-spin" style="position:absolute;left:8px;top:6px;"></i>
					<span class="text">Compute Coordinate Data</span>
				</button>
				<hr>
				<p style="text-align:center;">
				<span class="xor">Downloads</span><br>
	    	<a href="#" id="export-csv">Light-Twilight</a> |
	    	<a href="#" id="export-map">Lat-Lng</a> |
	    	<a href="#" id="export-json">All Data</a>
		    </p>

	    	<!--
				<div class="form-horizontal error-group">
				  <div class="control-group">
						<label class="control-label" for="cal-stop-date"></label>   
				    <div class="controls">
				    	<span class="xor">Downloads</span><br>
				    	<a href="#" id="export-csv">Light-Twilight CSV</a><br>
				    	<a href="#" id="export-json">All Data JSON</a><br>
				    	<a href="#" id="export-map">Lat-Lng CSV</a>
				    </div>
				  </div>
				</div>
				-->
				
				<!--
				<button class="submit btn btn-success" id="export-data">
					Download Data as JSON
				</button>
				-->

			</div> <!-- well -->
		</div> <!-- controls span -->
	</div> <!-- row -->

</div>

</body>
</html>